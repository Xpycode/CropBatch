# Code Review Report - CropBatch
**Date:** 2026-01-04
**Time:** 22:57:04
**Project:** CropBatch (macOS)

## 1. Executive Summary
The CropBatch application exhibits a mature and modern SwiftUI architecture. It effectively leverages recent Swift features like the `@Observable` macro and Actors to manage state and concurrency. The application follows a clear separation of concerns in its business logic, though the UI layer—specifically the main editor view—is beginning to suffer from monolithic bloat. Performance is well-considered with caching strategies and parallel image processing.

## 2. Architecture & Design Patterns

### 2.1. State Management (Facade Pattern)
The app uses a centralized `AppState` class annotated with `@Observable`. This acts as a Facade, delegating specific domain logic to specialized managers (`ImageManager`, `CropManager`, `ExportCoordinator`, etc.).
- **Strengths:** This keeps the `AppState` from becoming a true "God Object" while providing Views with a single source of truth.
- **Weaknesses:** As the app grows, `AppState` effectively becomes a dependency magnet. The current delegation strategy is working well, but care must be taken to ensure it remains a pass-through layer.

### 2.2. Service Layer
Logic for heavy operations is correctly isolated in services like `ImageCropService`.
- **Pipeline:** The processing pipeline (Transform -> Blur -> Crop -> Resize -> Watermark) is logical and robust.
- **Coordinate Systems:** The application correctly distinguishes between screen points and image pixels. This is critical for macOS Retina support and has been implemented correctly in the latest iteration.

## 3. Concurrency & Thread Safety

### 3.1. Actors and Isolation
The use of `actor` for the `ThumbnailCache` is exemplary. It ensures thread safety for the underlying `NSCache` and `inFlight` task dictionary without complex locking mechanisms.

### 3.2. Task Management
- **De-duplication:** `ThumbnailCache` implements robust "in-flight" task tracking. If a second request for a thumbnail comes in while the first is generating, it awaits the existing task rather than spawning a duplicate.
- **Batch Processing:** `ImageCropService.batchCrop` utilizes `withThrowingTaskGroup` to parallelize exports. This is the correct modern approach for CPU-bound batch operations.

## 4. Code Quality & Implementation Details

### 4.1. SwiftUI Best Practices
- **Modern Syntax:** The code uses modern SwiftUI syntax (e.g., `.onChange(of:initial:)`).
- **Performance:** `CropEditorView` implements local state caching (`cachedScaledImage`) to prevent expensive core graphics rendering on every layout pass. This shows deep understanding of SwiftUI's render loop.

### 4.2. File Structure & Organization
- **Separation:** Models and Services are well-separated.
- **Naming:** Variable and type naming is descriptive and follows Swift API Design Guidelines.

## 5. Specific Component Analysis

### 5.1. `CropEditorView.swift` (Critical)
**Status:** ⚠️ Needs Refactoring
This file has grown to over 900 lines. It contains multiple inner types (`CropOverlayView`, `CropDimensionsOverlay`, `CropHandlesView`, `WatermarkPreviewOverlay`) that are substantial enough to be their own files.
- **Issue:** It violates the Single Responsibility Principle.
- **Risk:** High maintenance cost. Making a change to the watermark overlay requires recompiling and navigating the entire editor file.
- **Recommendation:** Extract all auxiliary views (overlays, handles, guides) into a `Views/Components/Editor` subdirectory.

### 5.2. `ThumbnailCache.swift`
**Status:** ✅ Excellent
The implementation is robust.
- **Minor Note:** `invalidate(for: url)` clears the *entire* cache. While safe, this is aggressive. Given the composite key structure (`url|size`), clearing specific entries is harder but could be optimized if cache invalidation performance becomes an issue.

### 5.3. `ImageCropService.swift`
**Status:** ✅ Good
The handling of EXIF orientation by normalizing the context before processing is a proactive fix for a common class of image processing bugs.

## 6. Recommendations

1.  **Refactor `CropEditorView`:** Immediately break this file apart. Create a folder `Views/EditorComponents` and move `CropOverlayView`, `CropHandlesView`, etc., into separate files.
2.  **Export Service:** Consider moving the export orchestration logic (file naming, folder creation) out of `AppState` and into a dedicated `ExportService` that `ExportCoordinator` uses. `AppState` should only track *status*.
3.  **Testing:** The project has a `CropBatch-TestPlan.md`, but unit tests for `ImageCropService` (specifically coordinate math and aspect ratio calculations) should be verified or added if missing.

## 7. Proposed Fixes & Implementation Plan

Based on the investigation in section 5, the following fixes are proposed:

### 7.1. Refactoring `CropEditorView`
**Objective:** Modularize the monolithic editor view.
**Plan:**
1.  Create `Views/EditorComponents/` directory.
2.  Extract `CropOverlayView` (Lines ~535-580).
    *   **Dependencies:** `imageSize` (CGSize), `displayedSize` (CGSize), `cropSettings` (CropSettings).
3.  Extract `CropDimensionsOverlay` (Lines ~584-672).
    *   **Dependencies:** `Binding<CropSettings>`, `onDragEnded` closure.
4.  Extract `CropHandlesView` (Lines ~676-926) along with `EdgeHandle`, `CornerHandle`, and `PixelLabel`.
    *   **Dependencies:** `Binding<CropSettings>`, `SnapPoints`, `snapEnabled` (Bool), `snapThreshold` (Int).
5.  Extract `WatermarkPreviewOverlay` (Lines ~1045-1200).
    *   **Dependencies:** `ExportSettings` (via Environment/Binding), `displayedSize`.
6.  Extract `SnapGuidesView` (Lines ~1204-1262).
7.  Extract `AspectRatioGuideView` (Lines ~1000-1043).

### 7.2. Optimizing `ThumbnailCache`
**Objective:** Reduce aggressive cache clearing.
**Plan:**
1.  Add a tracking dictionary: `private var urlKeys: [URL: Set<NSString>] = [:]`.
2.  Update `thumbnail(for:size:)`: When generating a key, insert it into `urlKeys[url]`.
3.  Update `invalidate(for url:)`:
    *   Look up keys in `urlKeys[url]`.
    *   Iterate and call `cache.removeObject(forKey:)`.
    *   Remove entry from `urlKeys`.
**Benefit:** Prevents clearing thumbnails for *other* images when one image is updated (e.g., rotated), improving scroll performance in the grid view during batch editing operations.

### 7.3. Extracting Export Logic from `AppState`
**Objective:** Slim down `AppState` and improve testability.
**Plan:**
1.  Create `Services/ExportService.swift`.
2.  Move `processAndExport` and `processAndExportWithRename` logic from `AppState` to `ExportService`.
3.  Define `ExportService` as an actor or singleton to handle the file system operations.
4.  `AppState` should retain:
    *   `isProcessing` (State)
    *   `processingProgress` (State)
    *   Calls to `ExportService.shared.export(...)`
**Benefit:** Makes the export logic unit-testable without spinning up the entire AppState.

## 8. Conclusion
CropBatch is a high-quality codebase. The foundational architecture is sound, and concurrency is handled safely. The primary technical debt lies in the UI layer's monolithic views, which is a common trajectory in rapid SwiftUI development. Addressing this now will significantly improve maintainability.
# CropBatch Code Review Report

**Date:** 2026-01-02
**Branch:** `code-review`
**Reviewer:** Claude Opus 4.5
**Scope:** Full codebase review

---

## Executive Summary

CropBatch is a well-structured macOS SwiftUI application for batch image cropping with advanced features including blur regions, watermarks, transforms, and snap-to-edge detection. The codebase demonstrates modern Swift practices including `@Observable` macro usage, value-type models, and clean separation of concerns.

**Overall Assessment:** The codebase is of **good quality** with thoughtful architecture and comprehensive feature set. There are several areas for improvement around concurrency safety, code deduplication, and state management complexity.

**Note:** The blur/redact feature is **shelved** (UI hidden, code preserved) due to coordinate mismatch issues when images are rotated/flipped. See `docs/blur-feature-status.md` for details.

| Category | Rating | Notes |
|----------|--------|-------|
| Architecture | ★★★★☆ | Clean separation, could split AppState |
| Code Quality | ★★★★☆ | Well-documented, some duplication |
| Concurrency Safety | ★★★☆☆ | Several thread safety concerns |
| Error Handling | ★★★★☆ | Good LocalizedError usage |
| Performance | ★★★★☆ | Parallel processing, thumbnail caching |
| Maintainability | ★★★☆☆ | Large AppState, some magic numbers |

---

## Architecture Overview

### Project Structure
```
CropBatch/
├── CropBatchApp.swift      # App entry point, menu commands
├── ContentView.swift       # Main layout (NavigationSplitView + editors)
├── Models/
│   ├── AppState.swift      # Central observable state (~750 lines)
│   ├── CropSettings.swift  # Edge crop values
│   ├── ExportSettings.swift# Export configuration + profiles
│   ├── BlurRegion.swift    # Blur region model
│   ├── WatermarkSettings.swift # Watermark configuration
│   ├── ImageTransform.swift # Rotation/flip state
│   ├── NormalizedGeometry.swift # Coordinate system utilities
│   └── CropPreset.swift    # User/built-in presets
├── Views/
│   ├── CropEditorView.swift # Main image editor with overlays
│   ├── BlurEditorView.swift # Blur region drawing/editing
│   ├── ActionButtonsView.swift # Sidebar action buttons
│   └── ...                  # Other view components
└── Services/
    ├── ImageCropService.swift # Image processing pipeline
    ├── ThumbnailCache.swift   # NSCache-based caching
    ├── FolderWatcher.swift    # Auto-crop watched folder
    ├── RectangleDetector.swift # Vision-based edge detection
    ├── PresetManager.swift    # Preset persistence
    └── CLIHandler.swift       # Command-line interface
```

### Key Design Patterns

1. **Observable State Pattern**: `AppState` uses Swift's `@Observable` macro for reactive UI updates
2. **Service Layer**: Pure functions in `ImageCropService` for thread-safe image processing
3. **Normalized Coordinates**: Resolution-independent coordinate system for blur regions (0.0-1.0)
4. **Singleton Services**: `ThumbnailCache.shared`, `PresetManager.shared`, `FolderWatcher.shared`

---

## Strengths

### 1. Well-Documented Complex Logic
The codebase contains excellent inline documentation for non-obvious behavior:

```swift
// From ImageCropService.swift:413
// ┌─────────────────────────────────────────────────────────────────────┐
// │  CRITICAL: Image Orientation Handling                              │
// │                                                                     │
// │  NSImage.cgImage(forProposedRect:) returns RAW pixel data that     │
// │  may NOT match the displayed orientation...                        │
// └─────────────────────────────────────────────────────────────────────┘
```

### 2. Robust Coordinate System
`NormalizedGeometry.swift` provides a clean abstraction for handling coordinate conversions between:
- Normalized (0.0-1.0, resolution-independent)
- Pixel (top-left origin)
- CGImage (bottom-left origin)
- View (screen coordinates)

The transform support for rotation/flip is particularly well-implemented:
```swift
extension NormalizedRect {
    func applyingTransform(_ transform: ImageTransform) -> NormalizedRect
    func applyingInverseTransform(_ transform: ImageTransform) -> NormalizedRect
}
```

### 3. Thread-Safe Image Processing
`ImageCropService` uses pure `static` functions that don't mutate shared state:
```swift
static func crop(_ image: NSImage, with settings: CropSettings) throws -> NSImage
static func applyTransform(_ image: NSImage, transform: ImageTransform) -> NSImage
static func applyBlurRegions(_ image: NSImage, regions: [BlurRegion]) -> NSImage
```

### 4. Parallel Batch Processing
Export uses `TaskGroup` for concurrent processing with progress tracking:
```swift
return try await withThrowingTaskGroup(of: (Int, URL).self) { group in
    for (index, item) in items.enumerated() {
        group.addTask {
            let outputURL = try processSingleImage(...)
            return (index, outputURL)
        }
    }
    // Collect results...
}
```

### 5. Comprehensive Error Types
```swift
enum ImageCropError: LocalizedError {
    case failedToGetCGImage
    case invalidCropRegion
    case failedToCreateDestination
    case failedToWriteImage
    case wouldOverwriteOriginal(String)
    case filenameCollision(String)

    var errorDescription: String? { ... }
}
```

### 6. CLI Support
The app supports command-line usage for automation:
```bash
CropBatch -t 60 -b 34 -f jpg -q 85 *.png
```

---

## Issues & Recommendations

### Critical Issues

#### 1. FolderWatcher Thread Safety Concern
**File:** `CropBatch/Services/FolderWatcher.swift:49`
**Severity:** Medium

The `FolderWatcher` is marked `@MainActor` but creates a dispatch source with `.main` queue. While this should work, the pattern is fragile:

```swift
let source = DispatchSource.makeFileSystemObjectSource(
    fileDescriptor: fileDescriptor,
    eventMask: .write,
    queue: .main  // Relies on .main == @MainActor
)
```

**Risk:** If Apple's GCD implementation changes or there are subtle timing issues, the `[weak self]` closure could execute in an unexpected context.

**Recommendation:** Use `MainActor.run` explicitly in the event handler:
```swift
source.setEventHandler { [weak self] in
    Task { @MainActor in
        self?.checkForNewFiles()
    }
}
```

#### 2. ThumbnailCache Async/Sendable Mismatch
**File:** `CropBatch/Services/ThumbnailCache.swift:6`
**Severity:** Medium

```swift
final class ThumbnailCache: @unchecked Sendable {
    func thumbnail(for url: URL, size: CGSize) async -> NSImage? {
        // NSCache is thread-safe, but this async function could be called
        // from multiple concurrent contexts
    }
}
```

While `NSCache` is thread-safe for get/set, the logic pattern (check-then-generate-then-set) has a race condition where two concurrent calls could generate the same thumbnail.

**Recommendation:** Add a generation lock or use an actor:
```swift
actor ThumbnailCache {
    private var inFlight: [URL: Task<NSImage?, Never>] = [:]

    func thumbnail(for url: URL, size: CGSize) async -> NSImage? {
        if let existing = inFlight[url] {
            return await existing.value
        }
        let task = Task { await generateThumbnail(...) }
        inFlight[url] = task
        let result = await task.value
        inFlight[url] = nil
        return result
    }
}
```

### High Priority

#### 3. Large AppState Class
**File:** `CropBatch/Models/AppState.swift`
**Severity:** Medium

`AppState` is ~750 lines with 50+ properties and methods covering:
- Image management
- Crop settings
- Export settings
- Blur regions
- Transforms
- Snap points
- Undo/redo history

**Problems:**
- Difficult to test individual features in isolation
- Changes to one feature area require understanding the entire class
- All views observe the entire state even when they only need a subset

**Recommendation:** Consider splitting into focused managers:
```swift
@Observable final class ImageManager { ... }
@Observable final class CropManager { ... }
@Observable final class ExportManager { ... }
@Observable final class BlurManager { ... }

@Observable final class AppState {
    let images = ImageManager()
    let crop = CropManager()
    let export = ExportManager()
    let blur = BlurManager()
}
```

#### 4. Duplicate Export Logic
**File:** `CropBatch/ContentView.swift`
**Severity:** Medium

`ExportSectionView` (lines ~525-650) and `ExportFooterView` (lines ~340-460) contain nearly identical logic for:
- File dialog handling
- Overwrite checking
- Export execution

**Recommendation:** Extract shared logic to a dedicated `ExportCoordinator`:
```swift
@Observable final class ExportCoordinator {
    func selectOutputFolder() { ... }
    func processImages(_ images: [ImageItem], to: URL) async throws { ... }
    func executeExport(...) async throws { ... }
}
```

### Medium Priority

#### 5. Magic Numbers
Various hardcoded values should be constants:

| Value | Location | Purpose |
|-------|----------|---------|
| `50` | AppState.swift:127 | Undo history limit |
| `0.02` | BlurEditorView.swift:132 | Minimum blur region size |
| `100` | ThumbnailCache.swift:11 | Cache count limit |
| `50 * 1024 * 1024` | ThumbnailCache.swift:12 | Cache size limit (50MB) |
| `15` | AppState.swift:81 | Default snap threshold |
| `5` | AppState.swift:92 | Recent presets limit |

**Recommendation:** Create a configuration namespace:
```swift
enum Config {
    enum History {
        static let maxUndoSteps = 50
    }
    enum Blur {
        static let minimumRegionSize = 0.02
    }
    enum Cache {
        static let thumbnailCountLimit = 100
        static let thumbnailSizeLimit = 50 * 1024 * 1024
    }
}
```

#### 6. Silent Error Handling
**File:** `CropBatch/Services/PresetManager.swift:75`

```swift
private func loadUserPresets() {
    guard let data = UserDefaults.standard.data(forKey: userDefaultsKey) else { return }
    do {
        userPresets = try JSONDecoder().decode([CropPreset].self, from: data)
    } catch {
        print("Failed to load user presets: \(error)")  // Silent failure
    }
}
```

User data corruption is silently ignored. Similar patterns in `PresetManager.persistUserPresets()`.

**Recommendation:** Add error reporting to the user:
```swift
@Published var lastError: PresetError?

func loadUserPresets() {
    // ... decode ...
    catch {
        lastError = .loadFailed(error)
    }
}
```

#### 7. Unbounded Memory Usage
**File:** `CropBatch/Models/AppState.swift`

All loaded images are held in memory:
```swift
var images: [ImageItem] = []  // No limit
```

For users batch-processing hundreds of large images, this could cause memory pressure.

**Recommendation:** Consider lazy loading or memory-mapped access for large batches, or add a warning when memory usage is high.

### Low Priority

#### 8. Inconsistent Error Propagation
Some methods throw errors while similar methods silently fail:

| Method | Behavior |
|--------|----------|
| `ImageCropService.crop()` | throws |
| `ImageCropService.resize()` | returns original on failure |
| `ImageCropService.rotate()` | returns original on failure |

**Recommendation:** Standardize on throwing for all image operations, or document the design decision.

#### 9. Missing Accessibility Labels
Several custom views lack accessibility support:
- `EdgeHandle` (crop edge handles)
- `BlurRegionOverlay`
- `WatermarkPreviewOverlay`

**Recommendation:** Add `.accessibilityLabel()` and `.accessibilityHint()` modifiers.

#### 10. Shelved Features (Not Dead Code)
**Files:** `CropBatchApp.swift:131-162`, `ContentView.swift:~191`

Two features are intentionally shelved with code preserved:

1. **Rotation/Flip menu items** - disabled with `#if false` (breaks crop state)
2. **Blur tool** - filtered out in UI but fully implemented

The blur feature works for non-transformed images but has unresolved coordinate issues when images are rotated/flipped. See `docs/blur-feature-status.md` for detailed analysis.

**Recommendation:** These are tracked issues, not dead code. Consider adding `// TODO:` markers linking to issue tracker.

---

## Security Considerations

### 1. File Path Handling
The CLI handler properly expands tilde paths and validates file existence:
```swift
let expandedPath = (path as NSString).expandingTildeInPath
```

### 2. No Arbitrary Code Execution
Image processing uses Core Graphics/Core Image without external shell commands.

### 3. Sandboxing
The app uses an entitlements file but the specific sandbox configuration should be reviewed:
- Verify only necessary file access is granted
- Review any network entitlements

---

## Performance Observations

### Positives
1. **Parallel export processing** via TaskGroup
2. **Thumbnail caching** with memory limits
3. **Lazy snap point detection** (on-demand, cached)
4. **GPU-accelerated blur** via CIContext

### Potential Bottlenecks
1. **Full image loading** on import (no progressive loading)
2. **Synchronous EXIF normalization** in `createNormalizedCGImage()`
3. **No export cancellation** once started

---

## Testing Recommendations

### Unit Tests Needed
1. `NormalizedRect` coordinate transformations
2. `CropSettings.croppedSize()` calculations
3. `ExportSettings.outputFilename()` pattern handling
4. `RenameSettings.processPattern()` token substitution

### Integration Tests Needed
1. Full export pipeline with blur + crop + watermark
2. FolderWatcher file detection
3. CLI argument parsing edge cases

### UI Tests Needed
1. Crop handle dragging with snap
2. Blur region draw/move/resize
3. Watermark positioning

---

## Summary of Action Items

| Priority | Issue | Effort |
|----------|-------|--------|
| High | Fix ThumbnailCache race condition | 2 hours |
| High | Refactor AppState into smaller managers | 1 day |
| Medium | Extract export coordination logic | 3 hours |
| Medium | Add configuration constants | 1 hour |
| Medium | Improve error visibility | 2 hours |
| Low | Add accessibility labels | 2 hours |
| Low | Clean up dead code | 30 min |

---

## Conclusion

CropBatch is a well-engineered application with thoughtful design decisions around image processing, coordinate systems, and user experience. The main areas for improvement are:

1. **Concurrency safety** in singleton services
2. **State management scalability** as features grow
3. **Code deduplication** in export-related views

The codebase is maintainable and the inline documentation is excellent. With the recommended improvements, particularly around state management architecture, the app would be well-positioned for continued feature development.

---

*Report generated by Claude Opus 4.5 for CropBatch v1.0*

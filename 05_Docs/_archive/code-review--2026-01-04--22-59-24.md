# CropBatch Comprehensive Code Review

**Date**: January 4, 2026
**Reviewer**: Claude Code (Automated Review)
**Codebase Version**: Commit `139d4dd` (main branch)

---

## Executive Summary

| Category | Critical | Important | Total |
|----------|----------|-----------|-------|
| Models Layer | 7 | 2 | 9 |
| Views Layer | 6 | 4 | 10 |
| Services Layer | 4 | 4 | 8 |
| **Total** | **17** | **10** | **27** |

### Overall Assessment: **GOOD with Critical Issues**

The CropBatch codebase demonstrates solid SwiftUI architecture with good separation of concerns, comprehensive documentation, and proper use of modern Swift patterns (@Observable, actors). However, several critical issues around thread safety, memory management, and state synchronization need immediate attention before production deployment.

---

## Table of Contents

1. [Critical Issues](#critical-issues)
2. [Important Issues](#important-issues)
3. [Architecture Assessment](#architecture-assessment)
4. [Recommendations](#recommendations)

---

## Critical Issues

### MODELS LAYER

#### M1. Thread Safety Violation in ImageManager.showImportPanel()
**File**: `CropBatch/Models/ImageManager.swift:126-146`
**Confidence**: 95%

**Issue**: The `inout` parameters `exportSettings` and `selectedPresetID` are copied to local variables. The panel callback modifies these local copies, but changes are never written back to the original parameters.

```swift
@MainActor
func showImportPanel(exportSettings: inout ExportSettings, selectedPresetID: inout String?) {
    var settings = exportSettings          // LOCAL COPY
    var presetID = selectedPresetID        // LOCAL COPY

    panel.begin { [weak self] response in
        Task { @MainActor in
            self?.addImages(from: urls, exportSettings: &settings, selectedPresetID: &presetID)
            // Changes to settings/presetID are LOST!
        }
    }
}
```

**Impact**: Any auto-format detection during image import is silently lost. Users may wonder why their export format doesn't match imported images.

**Fix**: Remove `inout` pattern; use callback or direct reference to AppState.

---

#### M2. Race Condition in Export Methods
**File**: `CropBatch/Models/AppState.swift:419-443, 446-540`
**Confidence**: 85%

**Issue**: Multiple `@MainActor` async export methods access shared mutable state (`isProcessing`, `processingProgress`, `blurRegions`) without mutual exclusion. If called concurrently, data races occur.

```swift
@MainActor
func processAndExport(...) async throws -> [URL] {
    isProcessing = true        // Not synchronized
    defer { isProcessing = false }  // What if another export started?

    // Uses imageTransform and blurRegions which could change mid-export
}
```

**Impact**: Double-triggering export can leave UI in inconsistent state and produce incorrect files.

**Fix**: Add export task cancellation or mutual exclusion.

---

#### M3. Memory Leak in BlurManager.clearRegions()
**File**: `CropBatch/Models/BlurManager.swift:48-52`
**Confidence**: 85%

**Issue**: Creates empty `ImageBlurData` entry instead of removing the key entirely.

```swift
func clearRegions(for imageID: UUID) {
    regions[imageID] = ImageBlurData()  // Creates empty entry!
    selectedRegionID = nil
}
```

**Impact**: Dictionary grows unbounded as images are added/removed.

**Fix**: Use `regions.removeValue(forKey: imageID)`.

---

#### M4. Inconsistent Transform API (Global vs Per-Image)
**File**: `CropBatch/Models/AppState.swift:335-361`
**Confidence**: 90%

**Issue**: `transformForImage(_ imageID: UUID)` ignores the `imageID` parameter entirely, returning a global transform for all images.

```swift
func transformForImage(_ imageID: UUID) -> ImageTransform {
    blurManager.transform  // imageID completely ignored!
}
```

**Impact**: API is misleading. Rotating one image rotates ALL images.

**Fix**: Either implement per-image transforms or rename to clarify global scope.

---

#### M5. Fragile Value Semantics in BlurManager.updateRegion()
**File**: `CropBatch/Models/BlurManager.swift:79-93`
**Confidence**: 100%

**Issue**: Pattern creates copy, mutates copy, writes back. Any early return after mutation but before write-back silently loses changes.

```swift
func updateRegion(...) {
    guard var data = regions[imageID],  // Creates COPY
          let index = data.regions.firstIndex(...) else { return }

    data.regions[index].normalizedRect = ...  // Mutates copy
    // If future refactoring adds early return here, changes LOST
    regions[imageID] = data  // Must remember to write back
}
```

**Impact**: Not currently broken, but extremely fragile for maintenance.

**Fix**: Use direct subscript mutation pattern.

---

#### M6. Memory Leak with Weak Self in Export Callbacks
**File**: `CropBatch/Models/AppState.swift:438, 483`
**Confidence**: 80%

**Issue**: If `AppState` is deallocated during export, progress updates stop silently, export completes but UI never updates.

**Impact**: Poor UX and potential resource cleanup issues.

---

#### M7. Unsafe Mutable Captures in Panel Callback
**File**: `CropBatch/Models/ImageManager.swift:139-145`
**Confidence**: 82%

**Issue**: Mutating captured local variables from escaping closure after outer function returns creates undefined behavior.

---

### VIEWS LAYER

#### V1. NSCursor Stack Imbalance
**Files**: `ContentView.swift:489-494`, `ExportSettingsView.swift:694-700`, `CropEditorView.swift:614-618`, `CropSettingsView.swift:160-165`
**Confidence**: 95%

**Issue**: `NSCursor.push()`/`pop()` calls become unbalanced if view disappears mid-hover or drag state changes during hover.

```swift
.onHover { hovering in
    if hovering {
        NSCursor.resizeLeftRight.push()
    } else if !isDragging {
        NSCursor.pop()  // What if view disappears while hovering?
    }
}
```

**Impact**: Cursor gets stuck in wrong state across the app.

**Fix**: Add `.onDisappear` handler to clean up cursor state.

---

#### V2. Task Cancellation Missing in CropEditorView
**File**: `CropBatch/Views/CropEditorView.swift:275-280`
**Confidence**: 90%

**Issue**: Cache update tasks are never cancelled when new updates are triggered.

**Impact**: Multiple Tasks pile up on rapid image switching, wasting resources.

**Fix**: Store and cancel previous task before starting new one.

---

#### V3. State Mutation During View Update
**File**: `CropBatch/Views/CropEditorView.swift:233-245`
**Confidence**: 90%

**Issue**: Computed property `highQualityScaledImage` spawns Task that mutates `@State` during view body evaluation.

```swift
private var highQualityScaledImage: NSImage {
    Task { @MainActor in
        cachedScaledImage = newImage  // State mutation during render!
    }
    return newImage
}
```

**Impact**: Can cause infinite update loops, undefined rendering, potential crashes.

**Fix**: Move cache updates to `onChange` modifiers.

---

#### V4. Confirmation Dialog State Race Condition
**File**: `CropBatch/Views/ActionButtonsView.swift:180-201`
**Confidence**: 95%

**Issue**: Dialog captures state, user clicks button, dialog closes triggering `onChange` which clears state, then button handler Task starts with cleared state.

```swift
.onChange(of: showOverwriteDialog) { _, isShowing in
    if !isShowing {
        pendingExportImages = []  // Cleared BEFORE button Task runs!
    }
}
```

**Impact**: Export operations silently fail with empty file lists.

**Fix**: Clear state after export completes, not on dialog dismiss.

---

#### V5. TOCTOU Race in ThumbnailStripView
**File**: `CropBatch/Views/ThumbnailStripView.swift:111-120`
**Confidence**: 85%

**Issue**: `appState.images.count` can change between guard check and array access.

**Fix**: Capture array snapshot locally before iteration.

---

#### V6. Async/Await Race Condition in DropZoneView
**File**: `CropBatch/Views/DropZoneView.swift:57-64`
**Confidence**: 85%

**Issue**: `loadObject` callback creates uncoordinated Tasks for multiple dropped files.

---

### SERVICES LAYER

#### S1. Memory Leak in ThumbnailCache
**File**: `CropBatch/Services/ThumbnailCache.swift:49`
**Confidence**: 95%

**Issue**: `inFlight[key] = nil` doesn't remove the key from dictionary.

```swift
inFlight[key] = nil  // Should be: inFlight.removeValue(forKey: key)
```

**Impact**: Dictionary accumulates nil entries forever.

---

#### S2. Race Condition in FolderWatcher
**File**: `CropBatch/Services/FolderWatcher.swift:24-26, 43-74`
**Confidence**: 90%

**Issue**: `fileDescriptor` accessed from multiple threads without synchronization. `setCancelHandler` runs on arbitrary queue.

**Impact**: File descriptor corruption, potential crashes.

**Fix**: Mark `FolderWatcher` as `@MainActor`.

---

#### S3. File Descriptor Leak on Error
**File**: `CropBatch/Services/FolderWatcher.swift:43-47`
**Confidence**: 85%

**Issue**: If `DispatchSource.makeFileSystemObjectSource` fails after `open()` succeeds, file descriptor leaks.

**Fix**: Add cleanup in failure path:
```swift
guard let source = source else {
    close(fileDescriptor)
    fileDescriptor = -1
    return
}
```

---

#### S4. Thread Safety in ImageCropService.resize()
**File**: `CropBatch/Services/ImageCropService.swift:131-142`
**Confidence**: 82%

**Issue**: `NSGraphicsContext` used on non-main threads via TaskGroup in `batchCrop()`.

**Impact**: Undefined behavior, potential crashes in batch operations.

**Fix**: Use pure `CGContext` rendering instead of NSGraphicsContext.

---

## Important Issues

### Models Layer

| ID | Issue | Location | Confidence |
|----|-------|----------|------------|
| M8 | Missing proportional validation in crop adjustments | CropManager.swift:85-100 | 78% |
| M9 | Inconsistent cleanup between removeImages() and clearAll() | AppState.swift:210-220 | 75% |

### Views Layer

| ID | Issue | Location | Confidence |
|----|-------|----------|------------|
| V7 | Missing accessibility labels on interactive elements | Multiple | 85% |
| V8 | View identity hack using `.id()` modifier | ActionButtonsView.swift:201 | 80% |
| V9 | Memory growth from double-layered materials | BlurEditorView.swift:293-323 | 80% |
| V10 | Drag gesture state not reset on view disappear | Multiple gesture handlers | 85% |

### Services Layer

| ID | Issue | Location | Confidence |
|----|-------|----------|------------|
| S5 | Incomplete division by zero protection | FileSizeEstimator.swift:83 | 83% |
| S6 | Weak reference pattern fragility | ExportCoordinator.swift:27-35 | 81% |
| S7 | CIContext created per image (performance) | ImageCropService.swift:289 | 84% |
| S8 | Silent error in CLI directory creation | CLIHandler.swift:209-210 | 80% |

---

## Architecture Assessment

### Strengths

1. **Manager Pattern**: Clean refactoring of `AppState` into focused managers (ImageManager, CropManager, BlurManager, SnapPointsManager) improves maintainability.

2. **Value Types**: Extensive use of structs for data models provides good value semantics and implicit thread safety.

3. **Documentation**: Excellent inline documentation explaining coordinate system complexities and EXIF handling.

4. **Actor Isolation**: Proper use of actors in `ThumbnailCache` prevents most race conditions.

5. **SwiftUI Patterns**: Good use of `@Observable`, `@ViewBuilder`, and proper state management.

### Concerns

1. **Global Transform State**: Single global `ImageTransform` contradicts per-image architecture.

2. **Singleton Pattern**: `ExportProfileManager.shared` lacks thread safety and hinders testing.

3. **Mixed Paradigms**: Some code uses `@MainActor`, some uses DispatchQueue.main, some uses actors - should be more consistent.

---

## Recommendations

### Immediate (Before Production)

1. **Fix FolderWatcher race condition** (S2) - Can cause crashes
2. **Fix NSCursor stack management** (V1) - Affects UX across app
3. **Fix confirmation dialog state race** (V4) - Causes export failures
4. **Fix ImageCropService thread safety** (S4) - Can cause crashes in batch ops

### High Priority (Next Sprint)

5. **Fix ImageManager.showImportPanel()** (M1) - Silent data loss
6. **Add export mutual exclusion** (M2) - Prevents double-export issues
7. **Fix state mutation during view update** (V3) - Can cause crashes
8. **Fix ThumbnailCache memory leak** (S1) - Degrades over time

### Medium Priority (Technical Debt)

9. **Clarify transform architecture** (M4) - API clarity
10. **Fix BlurManager.clearRegions()** (M3) - Memory leak
11. **Add Task cancellation** (V2) - Performance
12. **Optimize CIContext reuse** (S7) - Performance
13. **Add accessibility labels** (V7) - Accessibility compliance

---

## Positive Observations

- Clean separation of concerns in manager pattern
- Comprehensive keyboard shortcut implementation
- Proper GeometryReader usage for coordinate calculations
- Excellent coordinate system documentation in NormalizedGeometry.swift
- Thoughtful memory management with configurable thresholds
- Well-structured preview overlays for watermarks and blur
- Good error handling patterns with enum-based error types

---

## Appendix: Files Reviewed

### Models (12 files)
- AppState.swift
- ImageManager.swift
- CropManager.swift
- BlurManager.swift
- SnapPointsManager.swift
- CropPreset.swift
- CropSettings.swift
- BlurRegion.swift
- WatermarkSettings.swift
- ExportSettings.swift
- ImageTransform.swift
- NormalizedGeometry.swift

### Views (12 files)
- ContentView.swift
- ExportSettingsView.swift
- BatchReviewView.swift
- BlurEditorView.swift
- DropZoneView.swift
- CropSettingsView.swift
- CropEditorView.swift
- PresetPickerView.swift
- FolderWatchView.swift
- ImageGridView.swift
- ActionButtonsView.swift
- ThumbnailStripView.swift

### Services (9 files)
- ImageCropService.swift
- ExportCoordinator.swift
- ThumbnailCache.swift
- FolderWatcher.swift
- FileSizeEstimator.swift
- UIDetector.swift
- RectangleDetector.swift
- CLIHandler.swift
- PresetManager.swift

### Other (2 files)
- CropBatchApp.swift
- Config.swift

---

## Detailed Fixes

This section provides complete, copy-paste ready fixes for each identified issue.

---

### M1. Fix ImageManager.showImportPanel() Thread Safety

**Problem**: `inout` parameters are copied to local variables; changes are lost after the async panel callback.

**Solution**: Remove `inout` pattern entirely. Pass a completion handler or restructure to call back into AppState.

```swift
// ===== CropBatch/Models/ImageManager.swift =====
// Replace lines 96-146

func addImages(from urls: [URL]) -> (detectedFormat: ExportFormat?, newImageCount: Int) {
    let wasEmpty = images.isEmpty

    let newImages = urls.compactMap { url -> ImageItem? in
        guard let image = NSImage(contentsOf: url) else { return nil }
        return ImageItem(url: url, originalImage: image)
    }
    images.append(contentsOf: newImages)

    // Set first image as active if none selected
    if activeImageID == nil {
        activeImageID = images.first?.id
    }

    // Return detected format for caller to handle
    var detectedFormat: ExportFormat? = nil
    if wasEmpty, let firstImage = newImages.first {
        let ext = firstImage.fileExtension
        detectedFormat = ExportFormat.allCases.first(where: {
            $0.fileExtension == ext || (ext == "jpeg" && $0 == .jpeg)
        })
    }

    return (detectedFormat, newImages.count)
}

/// Shows NSOpenPanel to import images
/// - Parameter completion: Called with detected format (if any) after import
@MainActor
func showImportPanel(completion: @escaping (ExportFormat?) -> Void) {
    let panel = NSOpenPanel()
    panel.title = "Import Images"
    panel.canChooseFiles = true
    panel.canChooseDirectories = false
    panel.allowsMultipleSelection = true
    panel.allowedContentTypes = [.png, .jpeg, .heic, .tiff, .bmp]

    panel.begin { [weak self] response in
        guard response == .OK else {
            completion(nil)
            return
        }
        let urls = panel.urls
        Task { @MainActor in
            guard let self = self else { return }
            let result = self.addImages(from: urls)
            completion(result.detectedFormat)
        }
    }
}

// ===== CropBatch/Models/AppState.swift =====
// Update the delegation method

@MainActor
func showImportPanel() {
    imageManager.showImportPanel { [weak self] detectedFormat in
        guard let self = self else { return }
        if let format = detectedFormat {
            self.exportSettings.format = format
            self.selectedPresetID = nil  // Mark as custom
        }
    }
}
```

---

### M2. Fix Export Race Condition

**Problem**: Multiple exports can run concurrently, causing state corruption.

**Solution**: Track the current export task and cancel any previous one.

```swift
// ===== CropBatch/Models/AppState.swift =====
// Add property after line 73

/// Currently running export task (for cancellation)
private var currentExportTask: Task<[URL], Error>?

// Replace processAndExport method (lines 417-443)

@MainActor
func processAndExport(images imagesToExport: [ImageItem]? = nil, to outputDirectory: URL) async throws -> [URL] {
    // Cancel any existing export
    currentExportTask?.cancel()

    let images = imagesToExport ?? (selectedImageIDs.isEmpty ? self.images : selectedImages)

    // Capture settings at start to prevent mid-export changes
    let capturedCropSettings = cropSettings
    let capturedTransform = imageTransform
    let capturedBlurRegions = blurRegions

    isProcessing = true
    processingProgress = 0

    let task = Task<[URL], Error> {
        defer {
            Task { @MainActor in
                self.isProcessing = false
                self.currentExportTask = nil
            }
        }

        try Task.checkCancellation()

        var settings = exportSettings
        settings.outputDirectory = .custom(outputDirectory)

        let results = try await ImageCropService.batchCrop(
            items: images,
            cropSettings: capturedCropSettings,
            exportSettings: settings,
            transform: capturedTransform,
            blurRegions: capturedBlurRegions
        ) { [weak self] progress in
            Task { @MainActor in
                self?.processingProgress = progress
            }
        }

        return results
    }

    currentExportTask = task
    return try await task.value
}
```

---

### M3. Fix BlurManager.clearRegions() Memory Leak

**Problem**: Creates empty entry instead of removing key.

**Solution**: Use `removeValue(forKey:)`.

```swift
// ===== CropBatch/Models/BlurManager.swift =====
// Replace lines 48-52

/// Clear all blur regions for an image
func clearRegions(for imageID: UUID) {
    regions.removeValue(forKey: imageID)
    if selectedRegionID != nil {
        // Check if selected region was in this image
        selectedRegionID = nil
    }
}
```

---

### M4. Clarify Transform API (Global vs Per-Image)

**Problem**: `transformForImage(_:)` ignores the imageID parameter.

**Solution**: Rename to clarify global scope, deprecate misleading method.

```swift
// ===== CropBatch/Models/AppState.swift =====
// Replace lines 334-354

/// The global transform applied to all images during export
/// Note: Currently CropBatch uses a single transform for all images.
/// Per-image transforms may be added in a future version.
var globalTransform: ImageTransform {
    blurManager.transform
}

@available(*, deprecated, message: "Use globalTransform instead. Per-image transforms not yet implemented.")
func transformForImage(_ imageID: UUID) -> ImageTransform {
    globalTransform
}

// Update all call sites to use globalTransform instead
```

---

### M5. Fix BlurManager.updateRegion() Value Semantics

**Problem**: Fragile copy-mutate-writeback pattern.

**Solution**: Use direct subscript mutation.

```swift
// ===== CropBatch/Models/BlurManager.swift =====
// Replace lines 79-93

/// Update a blur region's properties
func updateRegion(
    _ regionID: UUID,
    in imageID: UUID,
    normalizedRect: NormalizedRect? = nil,
    style: BlurRegion.BlurStyle? = nil,
    intensity: Double? = nil
) {
    // Early exit if image doesn't exist
    guard regions[imageID] != nil else { return }

    // Find index
    guard let index = regions[imageID]!.regions.firstIndex(where: { $0.id == regionID }) else { return }

    // Direct mutation via subscript (no copy needed)
    if let normalizedRect = normalizedRect {
        regions[imageID]!.regions[index].normalizedRect = normalizedRect.clamped()
    }
    if let style = style {
        regions[imageID]!.regions[index].style = style
    }
    if let intensity = intensity {
        regions[imageID]!.regions[index].intensity = intensity
    }
}
```

---

### V1. Fix NSCursor Stack Imbalance

**Problem**: Cursor push/pop becomes unbalanced if view disappears mid-hover.

**Solution**: Create a reusable view modifier with proper cleanup.

```swift
// ===== Create new file: CropBatch/Views/CursorModifier.swift =====

import SwiftUI
import AppKit

/// A view modifier that manages NSCursor state with proper cleanup
struct DraggableCursorModifier: ViewModifier {
    let normalCursor: NSCursor
    let draggingCursor: NSCursor?

    @Binding var isDragging: Bool
    @State private var isHovering = false
    @State private var cursorPushed = false

    func body(content: Content) -> some View {
        content
            .onHover { hovering in
                isHovering = hovering
                updateCursor()
            }
            .onChange(of: isDragging) { _, _ in
                updateCursor()
            }
            .onDisappear {
                // Critical: clean up cursor on view disappear
                if cursorPushed {
                    NSCursor.pop()
                    cursorPushed = false
                }
            }
    }

    private func updateCursor() {
        let shouldShowCursor = isHovering || isDragging
        let targetCursor = isDragging ? (draggingCursor ?? normalCursor) : normalCursor

        if shouldShowCursor && !cursorPushed {
            targetCursor.push()
            cursorPushed = true
        } else if shouldShowCursor && cursorPushed {
            // Swap cursor (pop old, push new)
            NSCursor.pop()
            targetCursor.push()
        } else if !shouldShowCursor && cursorPushed {
            NSCursor.pop()
            cursorPushed = false
        }
    }
}

extension View {
    /// Applies cursor management with automatic cleanup
    func draggableCursor(
        _ cursor: NSCursor,
        draggingCursor: NSCursor? = nil,
        isDragging: Binding<Bool>
    ) -> some View {
        modifier(DraggableCursorModifier(
            normalCursor: cursor,
            draggingCursor: draggingCursor,
            isDragging: isDragging
        ))
    }
}

// ===== Usage in CompactCropField (ContentView.swift) =====
// Replace lines 488-512

Text(label)
    .font(.system(size: 11, weight: .medium))
    .foregroundStyle(.secondary)
    .frame(width: 12)
    .draggableCursor(.resizeLeftRight, isDragging: $isDragging)
    .gesture(
        DragGesture(minimumDistance: 1)
            .onChanged { gesture in
                if !isDragging {
                    isDragging = true
                    dragStartValue = value
                }
                let delta = Int(gesture.translation.width / 2)
                value = max(0, min(maxValue, dragStartValue + delta))
            }
            .onEnded { _ in
                isDragging = false
                onCommit?()
            }
    )
```

---

### V2. Fix CropEditorView Task Cancellation

**Problem**: Cache update tasks pile up without cancellation.

**Solution**: Store and cancel previous task.

```swift
// ===== CropBatch/Views/CropEditorView.swift =====
// Add state property (around line 30)

@State private var cacheUpdateTask: Task<Void, Never>?

// Replace the Task in highQualityScaledImage (lines 275-280)

// Instead of spawning Task in computed property, use onChange:
.onChange(of: scaledImageSize) { _, newSize in
    updateImageCache(targetSize: newSize)
}
.onChange(of: currentTransform) { _, _ in
    updateImageCache(targetSize: scaledImageSize)
}
.onChange(of: image.id) { _, _ in
    updateImageCache(targetSize: scaledImageSize)
}
.onDisappear {
    cacheUpdateTask?.cancel()
}

// Add helper method
private func updateImageCache(targetSize: CGSize) {
    cacheUpdateTask?.cancel()
    cacheUpdateTask = Task { @MainActor in
        guard !Task.isCancelled else { return }

        let sourceImage = displayedImage
        guard targetSize.width > 0, targetSize.height > 0 else { return }

        guard let cgImage = sourceImage.cgImage(forProposedRect: nil, context: nil, hints: nil) else { return }

        let colorSpace = cgImage.colorSpace ?? CGColorSpaceCreateDeviceRGB()
        guard let context = CGContext(
            data: nil,
            width: Int(targetSize.width),
            height: Int(targetSize.height),
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        ) else { return }

        guard !Task.isCancelled else { return }

        context.interpolationQuality = .high
        context.draw(cgImage, in: CGRect(origin: .zero, size: targetSize))

        guard let scaledCGImage = context.makeImage() else { return }
        let newImage = NSImage(cgImage: scaledCGImage, size: targetSize)

        guard !Task.isCancelled else { return }

        cachedScaledImage = newImage
        cachedImageID = image.id
        cachedTargetSize = targetSize
        cachedTransform = currentTransform
    }
}
```

---

### V3. Fix State Mutation During View Update

**Problem**: Computed property mutates @State during body evaluation.

**Solution**: Refactor to use proper reactive patterns (see V2 fix above - same solution).

---

### V4. Fix Confirmation Dialog State Race

**Problem**: State cleared on dialog dismiss before button handler runs.

**Solution**: Don't clear state in onChange; clear after operation completes.

```swift
// ===== CropBatch/Views/ActionButtonsView.swift =====
// Remove the onChange that clears state (lines 199-205)

// Replace with clearing in executeExport:
private func executeExport(_ images: [ImageItem], to directory: URL, rename: Bool) async {
    do {
        let results: [URL]
        if rename {
            results = try await appState.processAndExportWithRename(images: images, to: directory)
        } else {
            results = try await appState.processAndExport(images: images, to: directory)
        }

        await MainActor.run {
            exportedCount = results.count
            lastExportDirectory = directory
            showExportCompleteAlert = true

            // Clear pending state AFTER export completes
            pendingExportImages = []
            pendingExportDirectory = nil
        }
    } catch {
        await MainActor.run {
            // Clear pending state on error too
            pendingExportImages = []
            pendingExportDirectory = nil
        }
        print("Export failed: \(error)")
    }
}

// Also remove the .id(dialogPresentationID) modifier - no longer needed
```

---

### V5. Fix TOCTOU Race in ThumbnailStripView

**Problem**: Array can change between count check and access.

**Solution**: Capture snapshot locally.

```swift
// ===== CropBatch/Views/ThumbnailStripView.swift =====
// Replace updateBufferCache method (around lines 105-130)

private func updateBufferCache() {
    // Capture snapshot to prevent race conditions
    let currentImages = appState.images
    let currentCount = currentImages.count

    guard currentCount > bufferCount else {
        cachedLeadingBuffer = []
        cachedTrailingBuffer = []
        cachedImageCount = currentCount
        return
    }

    guard cachedImageCount != currentCount else { return }

    cachedLeadingBuffer = (0..<bufferCount).compactMap { i in
        let sourceIndex = currentCount - bufferCount + i
        guard sourceIndex >= 0, sourceIndex < currentCount else { return nil }
        return BufferItem(id: "buffer-start-\(i)", item: currentImages[sourceIndex])
    }

    cachedTrailingBuffer = (0..<bufferCount).compactMap { i in
        guard i < currentCount else { return nil }
        return BufferItem(id: "buffer-end-\(i)", item: currentImages[i])
    }

    cachedImageCount = currentCount
}
```

---

### S1. Fix ThumbnailCache Memory Leak

**Problem**: `inFlight[key] = nil` doesn't remove the key.

**Solution**: Use `removeValue(forKey:)`.

```swift
// ===== CropBatch/Services/ThumbnailCache.swift =====
// Replace line 49

// Clean up in-flight tracking
inFlight.removeValue(forKey: key)
```

---

### S2 & S3. Fix FolderWatcher Race Condition and File Descriptor Leak

**Problem**: Race conditions and missing cleanup on error paths.

**Solution**: Already `@MainActor`, but need to fix the dispatch source setup.

```swift
// ===== CropBatch/Services/FolderWatcher.swift =====
// Replace startWatching method (lines 32-74)

func startWatching(folder: URL, output: URL) {
    guard !isWatching else { return }

    watchedFolder = folder
    outputFolder = output
    errorMessage = nil

    // Get initial list of files
    knownFiles = Set(existingFiles(in: folder))

    // Open folder for monitoring
    let fd = open(folder.path, O_EVTONLY)
    guard fd >= 0 else {
        errorMessage = "Cannot access folder"
        return
    }

    // Create dispatch source for file system events
    guard let source = DispatchSource.makeFileSystemObjectSource(
        fileDescriptor: fd,
        eventMask: .write,
        queue: .main
    ) else {
        // CRITICAL: Close fd on failure to prevent leak
        close(fd)
        errorMessage = "Failed to create file monitor"
        return
    }

    // Store fd only after successful source creation
    fileDescriptor = fd

    source.setEventHandler { [weak self] in
        // Already on main queue, no need for Task
        self?.checkForNewFiles()
    }

    source.setCancelHandler { [weak self] in
        // Already on main queue due to queue: .main
        guard let self = self else { return }
        if self.fileDescriptor >= 0 {
            close(self.fileDescriptor)
            self.fileDescriptor = -1
        }
    }

    dispatchSource = source
    source.resume()
    isWatching = true
}
```

---

### S4. Fix ImageCropService Thread Safety

**Problem**: `NSGraphicsContext` used on non-main threads.

**Solution**: Use pure CGContext for drawing.

```swift
// ===== CropBatch/Services/ImageCropService.swift =====
// Replace resize method (lines 109-147)

/// Resizes an image to the specified dimensions using thread-safe CGContext
static func resize(_ image: NSImage, to targetSize: CGSize) throws -> NSImage {
    let targetWidth = Int(targetSize.width)
    let targetHeight = Int(targetSize.height)

    guard targetWidth > 0, targetHeight > 0 else {
        throw ImageCropError.invalidDimensions
    }

    // Get CGImage from NSImage
    guard let cgImage = image.cgImage(forProposedRect: nil, context: nil, hints: nil) else {
        throw ImageCropError.failedToGetCGImage
    }

    let colorSpace = cgImage.colorSpace ?? CGColorSpaceCreateDeviceRGB()
    guard let context = CGContext(
        data: nil,
        width: targetWidth,
        height: targetHeight,
        bitsPerComponent: 8,
        bytesPerRow: 0,
        space: colorSpace,
        bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
    ) else {
        throw ImageCropError.failedToCreateContext
    }

    // Set high quality interpolation for good downscaling
    context.interpolationQuality = .high

    // Draw using pure CGContext (thread-safe)
    let targetRect = CGRect(x: 0, y: 0, width: targetWidth, height: targetHeight)
    context.draw(cgImage, in: targetRect)

    guard let resizedCGImage = context.makeImage() else {
        throw ImageCropError.failedToResize
    }

    return NSImage(cgImage: resizedCGImage, size: targetSize)
}
```

---

### S7. Optimize CIContext Reuse

**Problem**: New CIContext created for every image with blur.

**Solution**: Use static cached instance.

```swift
// ===== CropBatch/Services/ImageCropService.swift =====
// Add near top of file (after imports)

/// Shared CIContext for blur operations (thread-safe)
private let sharedCIContext: CIContext = {
    CIContext(options: [
        .useSoftwareRenderer: false,
        .highQualityDownsample: true
    ])
}()

// Replace line 289 in applyBlurRegions
// FROM: let ciContext = CIContext(options: [.useSoftwareRenderer: false])
// TO: use the shared instance

static func applyBlurRegions(_ image: NSImage, regions: [BlurRegion]) -> NSImage {
    // ... existing code ...

    // Use shared context instead of creating new one
    guard let outputCGImage = sharedCIContext.createCGImage(
        currentImage,
        from: currentImage.extent
    ) else {
        return image
    }

    // ... rest of method ...
}
```

---

### S8. Fix Silent Error in CLI Directory Creation

**Problem**: `try?` silently ignores directory creation failure.

**Solution**: Handle error explicitly.

```swift
// ===== CropBatch/Services/CLIHandler.swift =====
// Replace lines 208-211

do {
    try FileManager.default.createDirectory(
        at: outputURL,
        withIntermediateDirectories: true,
        attributes: nil
    )
    exportSettings.outputDirectory = .custom(outputURL)
} catch {
    print("Error: Cannot create output directory '\(outputURL.path)': \(error.localizedDescription)")
    return 1
}
```

---

### V7. Add Accessibility Labels (Example)

**Problem**: Interactive custom controls lack accessibility.

**Solution**: Add labels to all custom controls.

```swift
// ===== Example for CompactCropField in ContentView.swift =====
// Add after the Text view

Text(label)
    .font(.system(size: 11, weight: .medium))
    .foregroundStyle(.secondary)
    .frame(width: 12)
    .accessibilityLabel("\(label) crop value")
    .accessibilityValue("\(value) pixels")
    .accessibilityHint("Drag left or right to adjust")
    .accessibilityAddTraits(.adjustable)
    .accessibilityAdjustableAction { direction in
        switch direction {
        case .increment:
            value = min(maxValue, value + 1)
        case .decrement:
            value = max(0, value - 1)
        @unknown default:
            break
        }
    }

// ===== Example for position grid dots in ExportSettingsView.swift =====

Button {
    settings.watermarkSettings.position = position
} label: {
    Circle()
        .fill(isSelected ? Color.accentColor : Color.secondary.opacity(0.3))
        .frame(width: 8, height: 8)
}
.buttonStyle(.plain)
.accessibilityLabel("Position \(position.rawValue)")
.accessibilityAddTraits(isSelected ? .isSelected : [])
```

---

## Fix Priority Matrix

| Priority | Issue | Effort | Risk if Unfixed |
|----------|-------|--------|-----------------|
| 游댮 P0 | S2/S3 FolderWatcher | Low | Crash |
| 游댮 P0 | S4 ImageCropService thread safety | Low | Crash |
| 游댮 P0 | V1 NSCursor stack | Medium | UX degradation |
| 游댮 P0 | V4 Dialog state race | Low | Silent failures |
| 游 P1 | M1 ImageManager inout | Medium | Data loss |
| 游 P1 | M2 Export race condition | Medium | Corruption |
| 游 P1 | V3 State mutation | Medium | Crash |
| 游리 P2 | S1 ThumbnailCache leak | Low | Memory growth |
| 游리 P2 | M3 BlurManager leak | Low | Memory growth |
| 游리 P2 | V2 Task cancellation | Low | Performance |
| 游릭 P3 | M4 Transform API clarity | Low | Confusion |
| 游릭 P3 | S7 CIContext reuse | Low | Performance |
| 游릭 P3 | V7 Accessibility | Medium | Compliance |

---

*Fixes researched and documented by Claude Code*
